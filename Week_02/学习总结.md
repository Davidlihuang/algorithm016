# 第二周学习笔记

## 树
### 二叉树的五个性质
### 二叉树的实现
1. 创建
2. 四种遍历的递归和非递归实现
- ①. 前序遍历
-- 递归实现
-- 迭代实现：需要借助栈来实现
- ②. 中序遍历
-- 递归实现
-- 迭代实现：需要借助栈来实现
- ③. 后序遍历
-- 递归实现
-- 迭代实现：需要借助栈来实现
- ④. 层序遍历
-- 迭代实现：需要借助队列实现
3. 线索化二叉树
二叉树的n个中会有n-1个指针域为空，为了提升内存的利用率，可以将这n-1个为空的指针域用于指向其前驱或则后继，将二叉树线索化为一个链表(链表是树的特殊结构)。、
- 思路：
- 代码示例：
4. 平衡二叉树
5. 排序二叉树

## 图

###  图的五种存储结构

1. 邻接矩阵

2. 邻接表

3. 十字链表

4. 邻接多重表

5. 边集数组
### 图的创建
1. 邻接矩阵
2. 邻接表
### 图的遍历

1. 深度优先(DFS)
   深度优先遍历类似于树的前序遍历。只能遍历任意顶点之间是相通的连通图，也就是说深度遍历只能作用于包含该顶点的连通分量。对于非连通的图，只需要对图的所有连通分量进行深度遍历。
- (1). DFS步骤
-- ①、指定一个顶点 Vi,  并将其标记为以遍历的状态visited[i] = true
-- ②、对顶点vi的数据进行处理，也可以只是打印显示
-- ③、对顶点Vi的所有未被访问国的邻接节点进行递归调用DFS。
- (2). 代码实例
-- ①、邻接矩阵
```cpp
/* 邻接矩阵的深度优先递归算法 */
bool visited[MAX];
void DFS(const MGraph &G, int i){
    visited[i] = True;
    std::cout << G.vexs[i] <<std::endl;
    for(int j =0; j< G.numVertexes; j++) {
        if (G.arc[i][j] ==  1 && !visited[j]) {
            DFS(G,j);
        }
    }
}
/* 邻接矩阵的深度遍历操作 */
void DFSTraverse(const MGraph &G) {
    for(int i =0; i< G.numVertexes; i++) {
        visited[i] = false;
    }
    for(int j =0; j<G.numVertexes; j++) {  
        if(!visited[j]){
            DFS(G, j);
        }
    }
}
```
-- ②、邻接表
```cpp
/* 邻接表的深度优先递归算法 */ 
void DFS(const GraphAdjList &GL, int i) {
    EdgeNode *p; visited[i] = TRUE; /* 打印顶点，也可以其他操作 */ 	       printf("%c ", GL->adjList[i].data); 
    p = GL->adjList[i].firstedge; 
	while (p) {
        if (!visited[p->adjvex]) /* 对为访问的邻接顶点递归调用 */ 	               DFS(GL, p->adjvex);
        p = p->next; 
    }
}
/* 邻接表的深度遍历操作 */ 
void DFSTraverse(const GraphAdjList &GL) {
    int i; 
    // 初始所有顶点状态都是未访问过的状态
    for (i = 0; i < GL->numVertexes; i++) {
        visited[i] = FALSE;
    }
    // 对未访问过的顶点调用DFS，若是连通图，只会执行一次
    for (i = 0; i < GL->numVertexes; i++) {
        if (!visited[i]) {
            DFS(GL, i);
        }        
    }
}
```

2. 广度优先（BFS）
广度优先遍历类似于树的层遍历，需要借助队列实现
- (1). BFS步骤:
- (2). BFS实现：
--①. 邻接矩阵
```cpp
/*邻接矩阵广度优先算法*/
void BFSTraverse(const MGraph& G) {
    int i, j;
    Queue Q;
    for(i = 0; i< G.numVertexes; i++) {
    	visited[i] = false;
    }
    InitQueue(&Q);
    
    //对每一个顶点做循环, 确保每一个连通分量都被遍历
    for(i = 0; i < G.numVertexes; i++) {
    	if(!visited[i]) {
    		visited[i] = true;
    		std::cout << G.vexs[i] <<std:: endl;
    		EnQueue(&Q, i); 
    		while (!QueueEmpty(Q)) {
    			DeQueue(&Q, i); //队首元素出队,赋值给i
    			for(j =0; j < G.numVexes; j++) {
    			    if(G.arc[i][j] == 1 && !visited[j]) {
    			        visited[j] = true;
    			        std::cout << G.vexs[j] <<std::endl;
    			        EnQueue(&Q, j);
    			    }
    			}
    		}
    	}
    }

}
```
--②. 邻接表
```cpp
/* 邻接表的广度遍历算法 */ 
void BFSTraverse(GraphAdjList GL) {
    int i; 
    EdgeNode *p; 
    Queue Q; 
    for (i = 0; i < GL->numVertexes; i++) 
        visited[i] = FALSE;
    InitQueue(&Q); 
    for (i = 0; i < GL->numVertexes; i++) {
        if (!visited[i]) {
            visited[i] = TRUE; /* 打印顶点，也可以其他操作 */
            printf("%c ", GL->adjList[i].data); 
            EnQueue(&Q, i);                 
            while (!QueueEmpty(Q)) {
                DeQueue(&Q, &i); /* 找到当前顶点边表链表头指针 */ 
                p = GL->adjList[i].firstedge; 
                while (p) {
                    /* 若此顶点未被访问 */ 
                    if (!visited[p->adjvex]) {
                        visited[p->adjvex] = TRUE; 
                        printf("%c ", GL->adjList[p->adjvex].data);                         /* 将此顶点入队列 */ 
                        EnQueue(&Q, p->adjvex);
                } /* 指针指向下一个邻接点 */ 
                p = p->next;
        } 
    } 
}
```
### 最小生成树
1. Prim-普里姆
   1. 关键是更新最小代价数组中的边。
   2. 代码实现
```cpp
/* Prim算法生成最小生成树 */ 
void MiniSpanTree_Prim(MGraph G) {
    int min, i, j, k; /* 保存相关顶点下标 */ 
    int adjvex[MAXVEX]; /* 保存相关顶点间边的权值 */ 
    int lowcost[MAXVEX]; /* 初始化第一个权值为0，即v0加入生成树 */ 
    /* lowcost的值为0，在这里就是此下标的顶点已经加入生成树 */ 
    lowcost[0] = 0; /* 初始化第一个顶点下标为0 */ 
    adjvex[0] = 0; /* 循环除下标为0外的全部顶点 */ 
    for (i = 1; i < G.numVertexes; i++) {
    /* 将v0顶点与之有边的权值存入数组 */ 
        lowcost[i] = G.arc[0][i]; /* 初始化都为v0的下标 */ 
        adjvex[i] = 0;
    } 
    for (i = 1; i < G.numVertexes; i++) {
        /* 初始化最小权值为∞， */ 
        /* 通常设置为不可能的大数字如32767、65535等 */ 
        min = INFINITY; 
        j = 1; 
        k = 0; 
        /* 循环全部顶点 */ 
        while (j < G.numVertexes) {
        /* 如果权值不为0且权值小于min */ 
        if (lowcost[j] != 0 && lowcost[j] < min) {
        /* 则让当前权值成为最小值 */ 
        min = lowcost[j]; 
        /* 将当前最小值的下标存入k */ 
        k = j;
        } 
        j++;
    } /* 打印当前顶点边中权值最小边 */ 
    printf("(%d,%d)", adjvex[k], k); 
    /* 将当前顶点的权值设置为0，表示此顶点已经完成任务 */ 
    lowcost[k] = 0; /* 循环所有顶点 */ 
    for (j = 1; j < G.numVertexes; j++) {
        /* 若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值 */ 
        if (lowcost[j] != 0 && G.arc[k][j] < lowcost[j]) {
        /* 将较小权值存入lowcost */
        lowcost[j] = G.arc[k][j]; 
        /* 将下标为k的顶点存入adjvex */ 
        adjvex[j] = k;
        } 
    } 
}
```
2. Kruskal-克鲁斯卡尔

### 最短路径 
1. DijKstra-迪杰斯特拉算法
2. Floyd-弗洛伊德算法
### 拓扑排序

### 关键路径

## leetcode刷题

### 104二叉树的最大深度 

1. 题目描述：求二叉树的最大深度

2. 解法：
解法有三种，但是都是建立再树的遍历的基础上，这三种方法分别是递归， 借助栈进行迭代， 借助队列进行层遍历。但是实际上可以分为广度优先和深度优先。
   1、递归：分别的递归遍历左子树和右子树，去最大的子树深度即为二叉树的最大深度。
   2、迭代：按照先序遍历的方式将所有的左子树压栈，每一次进栈深度都需要加一。栈顶结点的指针左孩子为空停止入栈，将栈顶元素弹出。若该结点的右孩子不为空，那么以右孩子为结点，将其所有左孩子入栈。重复以上过程直到遍历完所有结点。
   3、广度优先(层遍历基础上)： 
   层遍历：先将根结点入队作为第一个结点，然后将队列的第一个元素出对，并将其所有的孩子结点都加入到队尾。重复以上步骤直到队列为空。以上只是对于一个个结点进行处理，要求树的深度需要整层入队或出队然后计数才加一。因此可以再原来的基础上加一层循环，统计当前队列中的结点数然后枚举所有结点，全部出队，并将这些结点的孩子结点按顺序入队。这样就可以再处理每一层前计数加一就可以统计出数的深度了。
3. 代码示例：
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

 //三种方法实现:
 /*
 * 1、递归
 * 2、栈
 * 3、广度优先(层遍历修改)
 */
#include <stack>
class Solution {
public:
    int recursionDFS(TreeNode* root);
    int iterDFS(TreeNode* root);
    int iterBFS(TreeNode* root); 
    int maxDepth(TreeNode* root) {
        int d = 0;
        //d = recursionDFS(root);
        //d = iterDFS(root);
        d = iterBFS(root);
        return d;
    }
};
int Solution::recursionDFS(TreeNode* root) {
    if(root == NULL) {
        return 0;
    }
    // int lf = maxDepth(root->left) + 1;
    //int rt = maxDepth(root->right) + 1;
    //return (lf > rt) ? lf : rt;
    return max(maxDepth(root->left), maxDepth(root->right))+1;
}
int Solution::iterDFS(TreeNode* root) {
    if (root == NULL) return 0;
    stack<pair<TreeNode*, int>> s;
    TreeNode* p = root;
    int Maxdeep = 0, deep = 0;
    while(!s.empty() || p!= NULL) {
        while(p != NULL) {
            s.push(pair<TreeNode*, int>(p, ++deep));
            p = p->left;
        }
        p = s.top().first;
        deep =s.top().second;
        if(Maxdeep < deep) Maxdeep = deep;
        s.pop();
        p = p->right;
    }
    return Maxdeep;
}
int Solution::iterBFS(TreeNode* root) {
    if (root == NULL) return 0;
    deque<TreeNode*> que;
    que.push_back(root);
    int deep = 0;
    while(!que.empty()) {
        deep++;
        int num = que.size();
        for (int i = 1; i <= num; i++) {
            TreeNode* p = que.front();
            que.pop_front();
            if(p->left) que.push_back(p->left);
            if(p->right) que.push_back(p->right);

        }
    }

    return deep;
}
```
### 258 各位相加

1. 题目描述： 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。
2. 解法：
   1、递归
   2、暴力
   3、公式法
3. 代码示例：
```cpp
class Solution {
public:
    int addDigits(int num) {
    //暴力
    int temp=num;
    
    while (temp/10){
        int sum = 0;
        while(temp != 0){
            sum = sum + temp%10;
            temp /= 10;
        }
        temp = sum;
    }
    
    //公式
    if (num == 0) 
         return num;
    if (num % 9 == 0) 
        return 9;
    else 
        return num % 9;

    return temp;
    }
};
```



